<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Dumb Draw — Shape Rush</title>
<style>
  :root { --bg:#0f172a; --card:#131c31; --ink:#e2e8f0; --muted:#94a3b8; --accent:#22d3ee; --good:#22c55e; --warn:#f59e0b; --bad:#ef4444; }
  html,body { margin:0; height:100%; background:linear-gradient(180deg,#0b1224,#0f172a); color:var(--ink); font-family:system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji"; }
  .wrap { max-width:520px; margin:0 auto; padding:12px 12px 24px; }
  h1 { font-size:20px; margin:10px 0 8px; text-align:center; }
  .hud { display:flex; justify-content:space-between; align-items:center; gap:10px; background:var(--card); border:1px solid #1f2a44; border-radius:14px; padding:10px 12px; }
  .hud small{ color:var(--muted); display:block; }
  .score { font-weight:700; }
  .preview { position:relative; width:68px; height:68px; border-radius:10px; background:#0b1326; border:1px solid #1f2a44; display:grid; place-items:center; }
  .preview canvas { width:56px; height:56px; }
  .board { margin-top:12px; background:#0b1326; border:1px solid #1f2a44; border-radius:18px; overflow:hidden; }
  #draw { width:100%; touch-action:none; display:block; background:radial-gradient(1200px 500px at 50% -120%, #1a2a54 0%, #0b1326 60%); }
  .btns { display:flex; gap:8px; margin-top:10px; }
  button { flex:1; background:#0f1a33; color:var(--ink); border:1px solid #1f2a44; border-radius:12px; padding:10px; font-weight:600; }
  button:active { transform:translateY(1px); }
  .toast { text-align:center; margin-top:8px; color:var(--muted); min-height:18px; }
  .final { text-align:center; padding:18px; border:1px dashed #26365f; border-radius:14px; margin-top:12px; display:none; }
  .rank { font-size:20px; font-weight:800; margin-top:6px; }
  .legend { font-size:12px; color:var(--muted); text-align:center; margin-top:6px; }
</style>
</head>
<body>
  <div class="wrap">
    <h1>🌀 Dumb Draw — Shape Rush</h1>
    <div class="hud">
      <div>
        <div><small>Round</small><span id="round">1 / 5</span></div>
        <div class="score"><small>Last Score</small><span id="lastScore">–</span></div>
      </div>
      <div>
        <div><small>Total</small><span id="totalScore">0</span></div>
        <div><small>Shape</small><span id="shapeName">Circle</span></div>
      </div>
      <div class="preview"><canvas id="preview" width="56" height="56"></canvas></div>
    </div>

    <div class="board">
      <canvas id="draw" width="520" height="520"></canvas>
    </div>

    <div class="btns">
      <button id="clearBtn">Clear</button>
      <button id="skipBtn">Skip</button>
      <button id="restartBtn" style="display:none;">Restart</button>
    </div>
    <div class="toast" id="toast">Draw the shape and lift to submit.</div>

    <div class="final" id="finalBox">
      <div style="font-size:28px;font-weight:900" id="finalScore">Total: 0</div>
      <div class="rank" id="finalRank">Rank: Worm Doodler 🪱</div>
      <div class="legend">Tap <b>Restart</b> to play another 5 random shapes.</div>
    </div>
  </div>

<script>
(() => {
  // ---------- Utility ----------
  const lerp = (a,b,t)=>a+(b-a)*t;
  const dist = (a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
  const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
  const polylineLength = (pts)=>pts.reduce((s,p,i)=> i? s+dist(pts[i-1],p):0,0);
  const resample = (pts, n=200) => {
    if (pts.length<2) return pts.slice();
    const L = polylineLength(pts);
    if (!L) return pts.slice();
    const step = L/(n-1);
    let d=0, i=1, out=[pts[0]];
    while (out.length<n && i<pts.length){
      const a=pts[i-1], b=pts[i];
      const seg = dist(a,b);
      if ((d+seg)>=step){
        const t=(step-d)/seg;
        out.push({x: lerp(a.x,b.x,t), y: lerp(a.y,b.y,t)});
        // insert virtual point at new position
        pts.splice(i,0,out[out.length-1]);
        d=0; i++;
      } else { d+=seg; i++; }
    }
    if (out.length<n) out.push(pts[pts.length-1]);
    return out;
  };
  const bbox = (pts)=>{
    let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
    for(const p of pts){ if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; }
    return {minX,minY,maxX,maxY, w:maxX-minX, h:maxY-minY};
  };
  const normalizeToBox = (pts, targetBox, pad=0){
    if(!pts.length) return [];
    const b=bbox(pts);
    const sx = (targetBox.w-2*pad)/(b.w||1);
    const sy = (targetBox.h-2*pad)/(b.h||1);
    const s = Math.min(sx,sy); // keep aspect
    const cx = (targetBox.minX+targetBox.maxX)/2;
    const cy = (targetBox.minY+targetBox.maxY)/2;
    const bx = (b.minX+b.maxX)/2, by=(b.minY+b.maxY)/2;
    return pts.map(p=>({ x: (p.x-bx)*s + cx, y: (p.y-by)*s + cy }));
  };
  const nearestAvgDistance = (A,B)=>{ // avg min distance from A to B
    if(!A.length||!B.length) return Infinity;
    let sum=0;
    for(const a of A){
      let best=Infinity;
      // local search: check only some neighbors (sampled)
      for(let i=0;i<B.length;i+=3){
        const d= (a.x-B[i].x)*(a.x-B[i].x) + (a.y-B[i].y)*(a.y-B[i].y);
        if(d<best) best=d;
      }
      sum += Math.sqrt(best);
    }
    return sum/A.length;
  };

  // ---------- Shape generators (normalized 0..1) ----------
  function shapeCircle(t){ const a=2*Math.PI*t; return {x:0.5+0.42*Math.cos(a), y:0.5+0.42*Math.sin(a)}; }
  function shapeSquare(t){
    // param square perimeter
    const p = t*4;
    if (p<1) return {x: lerp(0.08,0.92,p), y:0.08};
    if (p<2) return {x:0.92, y: lerp(0.08,0.92,p-1)};
    if (p<3) return {x: lerp(0.92,0.08,p-2), y:0.92};
    return {x:0.08, y: lerp(0.92,0.08,p-3)};
  }
  function shapeTriangle(t){
    const A={x:0.5,y:0.08}, B={x:0.92,y:0.9}, C={x:0.08,y:0.9};
    const perAB=0.34, perBC=0.33; // rough split
    if (t<perAB) {
      const u=t/perAB; return {x: lerp(A.x,B.x,u), y: lerp(A.y,B.y,u)};
    } else if (t<perAB+perBC){
      const u=(t-perAB)/perBC; return {x: lerp(B.x,C.x,u), y: lerp(B.y,C.y,u)};
    } else {
      const u=(t-perAB-perBC)/(1-perAB-perBC); return {x: lerp(C.x,A.x,u), y: lerp(C.y,A.y,u)};
    }
  }
  function shapeStar(t){
    const R=0.42, r=R*0.4, cx=0.5, cy=0.5;
    const k=5, a=2*Math.PI*t*k;
    // interpolate along edges between outer/inner points
    const i=Math.floor(t*10), frac=(t*10 - i);
    const a0=(i)*Math.PI/5 - Math.PI/2, a1=(i+1)*Math.PI/5 - Math.PI/2;
    const rad0=(i%2===0? R: r), rad1=((i+1)%2===0? R: r);
    return { x: cx + lerp(rad0*Math.cos(a0), rad1*Math.cos(a1), frac),
             y: cy + lerp(rad0*Math.sin(a0), rad1*Math.sin(a1), frac) };
  }
  function shapeHeart(t){
    // cardioid-ish heart, normalized
    const a = 2*Math.PI*t;
    const x = 0.5 + 0.36 * Math.pow(Math.sin(a),3);
    const y = 0.5 - 0.26*( 13*Math.cos(a)-5*Math.cos(2*a)-2*Math.cos(3*a)-Math.cos(4*a) )/13;
    return {x,y};
  }

  const SHAPES = [
    {name:"Circle", gen:shapeCircle},
    {name:"Square", gen:shapeSquare},
    {name:"Triangle", gen:shapeTriangle},
    {name:"Star", gen:shapeStar},
    {name:"Heart", gen:shapeHeart},
  ];

  // ---------- Setup ----------
  const canvas = document.getElementById('draw');
  const ctx = canvas.getContext('2d');
  const prevCanvas = document.getElementById('preview');
  const pctx = prevCanvas.getContext('2d');

  const roundEl = document.getElementById('round');
  const lastScoreEl = document.getElementById('lastScore');
  const totalScoreEl = document.getElementById('totalScore');
  const shapeNameEl = document.getElementById('shapeName');
  const toast = document.getElementById('toast');
  const finalBox = document.getElementById('finalBox');
  const finalScore = document.getElementById('finalScore');
  const finalRank = document.getElementById('finalRank');
  const clearBtn = document.getElementById('clearBtn');
  const skipBtn = document.getElementById('skipBtn');
  const restartBtn = document.getElementById('restartBtn');

  const PAD = 24;
  const boardBox = {minX:PAD, minY:PAD, maxX:canvas.width-PAD, maxY:canvas.height-PAD, get w(){return this.maxX-this.minX}, get h(){return this.maxY-this.minY}};

  let rounds = 5;
  let order = [];
  let idx = 0;
  let total = 0;
  let drawing=false;
  let stroke=[];

  function pickOrder(){
    // random 5 (allow repeats if > shapes)
    const pool=[...SHAPES, ...SHAPES]; // more variety
    order = Array.from({length:rounds}, _=> pool[Math.floor(Math.random()*pool.length)]);
    idx=0; total=0;
    lastScoreEl.textContent='–';
    totalScoreEl.textContent='0';
    finalBox.style.display='none';
    restartBtn.style.display='none';
    clearCanvas();
    renderHUD();
    renderTargetPreview();
    drawGuide();
  }

  function renderHUD(){
    roundEl.textContent=`${idx+1} / ${rounds}`;
    shapeNameEl.textContent = order[idx].name;
  }

  function clearCanvas(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGuide();
  }

  function drawGuide(){
    // faint board & target outline on main canvas
    ctx.save();
    ctx.lineWidth=1;
    ctx.strokeStyle='#1f2a44';
    ctx.fillStyle='#0b1326';
    ctx.strokeRect(boardBox.minX,boardBox.minY,boardBox.w,boardBox.h);

    // draw target outline lightly
    const pts = sampleShape(order[idx].gen, 240, boardBox);
    ctx.beginPath();
    for(let i=0;i<pts.length;i++){
      const p=pts[i];
      if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    }
    ctx.closePath();
    ctx.globalAlpha=0.15;
    ctx.strokeStyle= 'white';
    ctx.stroke();
    ctx.restore();
  }

  function renderTargetPreview(){
    pctx.clearRect(0,0,prevCanvas.width,prevCanvas.height);
    const bb = {minX:4,minY:4,maxX:prevCanvas.width-4,maxY:prevCanvas.height-4, get w(){return this.maxX-this.minX}, get h(){return this.maxY-this.minY}};
    const pts = sampleShape(order[idx].gen, 140, bb);
    pctx.beginPath();
    for(let i=0;i<pts.length;i++){
      const p=pts[i];
      if(i===0) pctx.moveTo(p.x,p.y); else pctx.lineTo(p.x,p.y);
    }
    pctx.closePath();
    pctx.lineWidth=2;
    pctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#22d3ee';
    pctx.stroke();
  }

  function sampleShape(gen, n, box){
    const pts=[];
    for(let i=0;i<n;i++){
      const t=i/(n-1);
      const p=gen(t);
      pts.push({ x: lerp(box.minX, box.maxX, p.x), y: lerp(box.minY, box.maxY, p.y) });
    }
    return pts;
  }

  // ---------- Drawing handlers ----------
  const getPos = (e)=>{
    const rect = canvas.getBoundingClientRect();
    const x = (e.touches? e.touches[0].clientX : e.clientX) - rect.left;
    const y = (e.touches? e.touches[0].clientY : e.clientY) - rect.top;
    return {x,y};
  };

  function startDraw(e){
    e.preventDefault();
    drawing=true; stroke=[];
    const p=getPos(e); stroke.push(p);
  }
  function moveDraw(e){
    if(!drawing) return;
    const p=getPos(e); stroke.push(p);
    // draw segment
    const a=stroke[stroke.length-2], b=stroke[stroke.length-1];
    ctx.strokeStyle='#e2e8f0';
    ctx.lineWidth=3;
    ctx.lineCap='round';
    ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
  }
  function endDraw(){
    if(!drawing) return;
    drawing=false;
    submitStroke();
  }

  canvas.addEventListener('mousedown', startDraw);
  canvas.addEventListener('mousemove', moveDraw);
  window.addEventListener('mouseup', endDraw);
  canvas.addEventListener('touchstart', startDraw, {passive:false});
  canvas.addEventListener('touchmove', moveDraw, {passive:false});
  canvas.addEventListener('touchend', endDraw);

  // ---------- Scoring ----------
  function scoreAgainst(targetPts, userPtsRaw){
    if (userPtsRaw.length<8) return 0;

    // Resample and normalize user to board box
    const userRes = resample(userPtsRaw.slice(), 220);
    const user = normalizeToBox(userRes, boardBox, 6);

    // Distance coverage (target -> user)
    const avgD = nearestAvgDistance(targetPts, user);
    const tol = Math.min(boardBox.w, boardBox.h) * 0.02; // ~2% board
    const coverage = Math.exp(-avgD / tol); // 1 (perfect) .. 0

    // Length factor (match perimeter)
    const tLen = polylineLength(targetPts);
    const uLen = polylineLength(user);
    const lenErr = Math.abs(uLen - tLen) / (tLen||1);
    const lenFactor = Math.exp(-lenErr*1.2);

    // Closure factor (encourage closed shapes)
    const closeGap = dist(user[0], user[user.length-1]) / (tLen||1);
    const closeFactor = Math.exp(-closeGap*6);

    // Final score
    const raw = 100 * (0.65*coverage + 0.20*lenFactor + 0.15*closeFactor);
    return Math.round(clamp(raw, 0, 100));
  }

  function submitStroke(){
    const target = sampleShape(order[idx].gen, 240, boardBox);
    const s = scoreAgainst(target, stroke);
    total += s;
    lastScoreEl.textContent = `${s}`;
    totalScoreEl.textContent = `${total}`;
    // feedback color
    const c = s>=85? 'var(--good)' : s>=60? 'var(--warn)' : 'var(--bad)';
    toast.innerHTML = `Shape scored <b style="color:${c}">${s}</b>/100`;

    // advance
    idx++;
    if (idx>=rounds){
      finishGame();
    } else {
      renderHUD();
      clearCanvas();
      renderTargetPreview();
    }
  }

  function finishGame(){
    finalBox.style.display='block';
    restartBtn.style.display='block';
    finalScore.textContent = `Total: ${total}`;
    const rank =
      total >= 430 ? "Circle Master 🎯" :
      total >= 360 ? "Egg Drawer 🥚" :
      total >= 280 ? "Potato Artist 🥔" :
      total >= 200 ? "Oval Enjoyer 🥚➡️⭕" :
      "Worm Doodler 🪱";
    finalRank.textContent = `Rank: ${rank}`;
    toast.textContent = "Game over! Nice doodles.";
  }

  // ---------- Buttons ----------
  clearBtn.onclick = ()=>{ stroke=[]; clearCanvas(); toast.textContent="Cleared. Draw again."; };
  skipBtn.onclick = ()=>{
    lastScoreEl.textContent='0';
    idx++;
    if (idx>=rounds) finishGame();
    else { renderHUD(); clearCanvas(); renderTargetPreview(); toast.textContent="Skipped. Next shape."; }
  };
  restartBtn.onclick = ()=>{ pickOrder(); toast.textContent="New game. Draw the shape shown!"; };

  // ---------- Boot ----------
  pickOrder();
})();
</script>
</body>
</html>
